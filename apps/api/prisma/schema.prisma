generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Core ────────────────────────────────────────────────

model Tenant {
  id        String   @id @default(uuid())
  name      String
  slug      String   @unique
  rut       String?
  address   String?
  phone     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships          UserTenant[]
  aiConfig             AiProviderConfig?
  conversations        Conversation[]
  accounts             Account[]
  journalEntries       JournalEntry[]
  fiscalPeriods        FiscalPeriod[]
  documents            Document[]
  accountingSteps      AccountingProcessStep[]
  memories       Memory[]
  agentSkills    AgentSkill[]
  apiKeys        ApiKey[]

  @@map("tenants")
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  memberships        UserTenant[]
  conversations      Conversation[]
  documents          Document[]
  stepCompletions    AccountingStepCompletion[]
  memories              Memory[]
  journalEntriesCreated JournalEntry[]
  apiKeys               ApiKey[]

  @@map("users")
}

/// Membresía: un usuario puede pertenecer a múltiples tenants con roles distintos
model UserTenant {
  id        String     @id @default(uuid())
  role      UserRole   @default(OWNER)
  isActive  Boolean    @default(true)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([userId])
  @@index([tenantId])
  @@map("user_tenants")
}

enum UserRole {
  /// Rol inicial: acceso completo. Roles granulares se añadirán aquí en el futuro.
  OWNER
  ADMIN
  ACCOUNTANT
  VIEWER
}

// ─── AI ──────────────────────────────────────────────────

enum AiProvider {
  OPENAI

  @@map("ai_provider")
}

/// Configuracion de proveedor de IA por tenant
model AiProviderConfig {
  id              String      @id @default(uuid())
  provider        AiProvider  @default(OPENAI)
  encryptedApiKey String
  model           String      @default("gpt-5.2-2025-12-11")
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  tenantId String @unique
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("ai_provider_configs")
}

/// Sesion de chat entre un usuario y el asistente IA
model Conversation {
  id                  String  @id @default(uuid())
  title               String  @default("Nueva conversación")
  lastResponseId      String?
  /// The previous_response_id that was used when the last response was generated (used for manual context reconstruction)
  parentResponseId    String?
  /// Full response.output array from the last OpenAI response (needed for manual context on tool answer)
  lastResponseOutput  Json?
  pendingToolOutputs  Json?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  messages      Message[]
  documents     Document[]
  journalEntries JournalEntry[]

  @@index([userId])
  @@index([tenantId])
  @@map("conversations")
}

enum MessageRole {
  user
  assistant
  tool
  question

  @@map("message_role")
}

/// Mensaje individual dentro de una conversacion
model Message {
  id          String      @id @default(uuid())
  role        MessageRole
  content     Json
  toolName    String?
  toolArgs    Json?
  toolResult  Json?
  createdAt   DateTime    @default(now())

  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@map("messages")
}

// ─── Memory ──────────────────────────────────────────────

enum MemoryCategory {
  PREFERENCE
  FACT
  PROCEDURE
  DECISION
  CONTEXT

  @@map("memory_category")
}

/// Memoria persistente del asistente por tenant/usuario
model Memory {
  id         String         @id @default(uuid())
  content    String
  category   MemoryCategory @default(CONTEXT)
  /// Relevancia 1-10; el modelo asigna la importancia al guardar
  importance Int            @default(5)
  /// Embedding pgvector(1536) para búsqueda semántica — gestionado via raw SQL
  embedding  Unsupported("vector(1536)")?
  isActive   Boolean        @default(true)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  /// null = memoria de la organización; userId presente = memoria del usuario
  userId String?
  user   User?  @relation(fields: [userId], references: [id], onDelete: Cascade)

  /// Documento de origen (si la memoria fue extraída de un documento)
  documentId String?
  document   Document? @relation(fields: [documentId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId, tenantId])
  @@index([documentId])
  @@map("memories")
}

// ─── Accounting ──────────────────────────────────────────

model Account {
  id           String               @id @default(uuid())
  code         String
  name         String
  type         AccountType
  /// Sección IFRS IAS 1 (solo en cuentas REVENUE/EXPENSE). Se hereda del ancestro raíz.
  ifrsSection  AccountIFRSSection?
  isActive     Boolean              @default(true)
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt

  parentId String?
  parent   Account?  @relation("AccountHierarchy", fields: [parentId], references: [id])
  children Account[] @relation("AccountHierarchy")

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  journalEntryLines JournalEntryLine[]

  @@unique([code, tenantId])
  @@index([tenantId])
  @@map("accounts")
}

enum AccountType {
  ASSET
  LIABILITY
  EQUITY
  REVENUE
  EXPENSE
}

/// Clasificación funcional IFRS (IAS 1) para el Estado de Resultados.
/// Se asigna a cuentas de tipo REVENUE o EXPENSE para estructurar
/// la presentación por función: ingresos, costo de ventas, gastos operativos,
/// resultado financiero e impuesto.
enum AccountIFRSSection {
  REVENUE
  OTHER_INCOME
  COST_OF_SALES
  OPERATING_EXPENSE
  FINANCE_INCOME
  FINANCE_COST
  TAX_EXPENSE

  @@map("account_ifrs_section")
}

/// Origen del asiento: asistente IA o manual (formulario)
enum JournalEntrySource {
  ASSISTANT
  MANUAL

  @@map("journal_entry_source")
}

model JournalEntry {
  id          String             @id @default(uuid())
  number      Int
  date        DateTime
  description String
  status      JournalEntryStatus @default(DRAFT)
  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt

  /// Usuario que creó el asiento (manual o quien confirmó en el asistente)
  createdById  String?
  createdBy    User?     @relation(fields: [createdById], references: [id], onDelete: SetNull)
  /// Origen: asistente o manual
  createdVia   JournalEntrySource?
  /// Conversación del asistente donde se creó (solo si createdVia = ASSISTANT)
  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)

  fiscalPeriodId String
  fiscalPeriod   FiscalPeriod @relation(fields: [fiscalPeriodId], references: [id])

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  lines     JournalEntryLine[]
  documents DocumentJournalEntry[]

  @@unique([number, tenantId])
  @@index([tenantId])
  @@index([date])
  @@index([createdById])
  @@index([conversationId])
  @@map("journal_entries")
}

enum JournalEntryStatus {
  DRAFT
  POSTED
  VOIDED
}

model JournalEntryLine {
  id          String  @id @default(uuid())
  debit       Decimal @default(0) @db.Decimal(18, 2)
  credit      Decimal @default(0) @db.Decimal(18, 2)
  description String?

  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)

  accountId String
  account   Account @relation(fields: [accountId], references: [id])

  @@index([journalEntryId])
  @@map("journal_entry_lines")
}

model FiscalPeriod {
  id        String             @id @default(uuid())
  name      String
  startDate DateTime
  endDate   DateTime
  status    FiscalPeriodStatus @default(OPEN)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  journalEntries      JournalEntry[]
  stepCompletions     AccountingStepCompletion[]

  @@index([tenantId])
  @@map("fiscal_periods")
}

enum FiscalPeriodStatus {
  OPEN
  CLOSED
}

/// Paso del proceso contable configurable por organización
model AccountingProcessStep {
  id          String   @id @default(uuid())
  name        String
  description String?
  order       Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  completions AccountingStepCompletion[]

  @@index([tenantId])
  @@map("accounting_process_steps")
}

/// Estado de completitud de un paso de proceso para un período fiscal
model AccountingStepCompletion {
  id          String     @id @default(uuid())
  status      StepStatus @default(PENDING)
  completedAt DateTime?
  notes       String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  stepId String
  step   AccountingProcessStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  fiscalPeriodId String
  fiscalPeriod   FiscalPeriod @relation(fields: [fiscalPeriodId], references: [id], onDelete: Cascade)

  completedById String?
  completedBy   User?  @relation(fields: [completedById], references: [id], onDelete: SetNull)

  @@unique([stepId, fiscalPeriodId])
  @@index([fiscalPeriodId])
  @@map("accounting_step_completions")
}

enum StepStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  SKIPPED
}

// ─── Documents ────────────────────────────────────────────

enum DocumentCategory {
  FACTURA
  BOLETA
  NOTA_CREDITO
  NOTA_DEBITO
  CONTRATO
  ESTATUTOS
  DECLARACION
  COMPROBANTE
  REMUNERACION
  OTRO
}

/// Documento adjunto: almacenado en S3, asociado a conversacion y asientos
model Document {
  id         String            @id @default(uuid())
  name       String
  s3Key      String
  mimeType   String
  sizeBytes  Int
  category   DocumentCategory  @default(OTRO)
  tags       String[]
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  uploadedById String
  uploadedBy   User   @relation(fields: [uploadedById], references: [id])

  conversationId String?
  conversation   Conversation? @relation(fields: [conversationId], references: [id], onDelete: SetNull)

  journalEntries DocumentJournalEntry[]
  memories       Memory[]

  @@index([tenantId])
  @@index([conversationId])
  @@map("documents")
}

/// Relacion muchos-a-muchos entre documentos y asientos contables
model DocumentJournalEntry {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())

  documentId String
  document   Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  journalEntryId String
  journalEntry   JournalEntry @relation(fields: [journalEntryId], references: [id], onDelete: Cascade)

  @@unique([documentId, journalEntryId])
  @@map("document_journal_entries")
}

// ─── Agent Skills ─────────────────────────────────────────

/// Skill instalado por un tenant para extender las capacidades del agente de IA
model AgentSkill {
  id          String   @id @default(uuid())
  name        String
  description String?
  repoUrl     String
  /// Contenido del SKILL.md (body sin frontmatter)
  content     String
  version     String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  files AgentSkillFile[]

  @@unique([tenantId, repoUrl])
  @@index([tenantId])
  @@map("agent_skills")
}

/// Archivo de referencia o script perteneciente a un AgentSkill
model AgentSkillFile {
  id      String @id @default(uuid())
  /// Ruta relativa dentro del skill, ej: "references/api_docs.md"
  path    String
  content String

  skillId String
  skill   AgentSkill @relation(fields: [skillId], references: [id], onDelete: Cascade)

  @@unique([skillId, path])
  @@index([skillId])
  @@map("agent_skill_files")
}

model ApiKey {
  id          String    @id @default(uuid())
  name        String
  keyPrefix   String
  keyHash     String    @unique
  scopes      String[]
  tenantId    String
  tenant      Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdById String
  createdBy   User      @relation(fields: [createdById], references: [id], onDelete: Cascade)
  lastUsedAt  DateTime?
  isActive    Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([keyHash])
  @@map("api_keys")
}

/// Registro de emails en lista de espera
model WaitlistEntry {
  id        String   @id @default(uuid())
  email     String   @unique
  createdAt DateTime @default(now())

  @@map("waitlist_entries")
}
